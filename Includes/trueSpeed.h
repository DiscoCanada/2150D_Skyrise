/*-----------------------------------------------------------------------------*/
/*                                                                             */
/*                        Copyright (c) Jordan Kiesel                          */
/*                                   2014                                      */
/*                            All Rights Reserved                              */
/*                                                                             */
/*-----------------------------------------------------------------------------*/
/*                                                                             */
/*    Module:     TrueSpeedGenerator.c                                         */
/*    Author:     Jordan Kiesel                                                */
/*    Created:    15 Sep 2014                                                  */
/*                                                                             */
/*    Revisions:                                                               */
/*                V1.00  25 Aug 2014 - Initial release                         */
/*-----------------------------------------------------------------------------*/
/*                                                                             */
/*    The author is supplying this software for use with the VEX cortex        */
/*    control system. This file can be freely distributed and teams are        */
/*    authorized to freely use this program, however, it is requested that     */
/*    improvements or additions be shared with the VEX community via the VEX   */
/*    Forum. Please acknowledge the work of the authors when appropriate.      */
/*    Thanks.                                                                  */
/*                                                                             */
/*    Licensed under the Apache License, Version 2.0 (the "License");          */
/*    you may not use this file except in compliance with the License.         */
/*    You may obtain a copy of the License at                                  */
/*                                                                             */
/*      http://www.apache.org/licenses/LICENSE-2.0                             */
/*                                                                             */
/*    Unless required by applicable law or agreed to in writing, software      */
/*    distributed under the License is distributed on an "AS IS" BASIS,        */
/*    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. */
/*    See the License for the specific language governing permissions and      */
/*    limitations under the License.                                           */
/*                                                                             */
/*    The author can be contacted on the VEX Forum as LegoMindstormsmaniac     */
/*    email: legomindstormsmaniac@gmail.com                                    */
/*    Member of VEXU team BNS, Bots 'n' Stuff Robotics, Princeton NJ.          */
/*    Mentor for VRC team 24, Super Sonic Sparks, New Windsor MD.              */
/*                                                                             */
/*-----------------------------------------------------------------------------*/
/*                                                                             */
/*    Description:                                                             */
/*                                                                             */
/*    This function is designed to generate a customized array to correct the  */
/*    non-linearity of VEX motors' PWM-to-RPM curve. Motors are run at every   */
/*    PWM value from -127 through 127 and integrated motor encoders are used   */
/*    to read the RPM at every value. An array is generated by picking PWM     */
/*    values that will yield as close to a linear relationship as possible     */
/*    between PWM value and RPM output. Integrated motor encoders are used to  */
/*    read motor speeds. Find more about trueSpeed at the following URL:       */
/*    http://www.vexforum.com/showthread.php?t=76943                           */
/*                                                                             */
/*-----------------------------------------------------------------------------*/

// Set All Drive Motors and One Encoder Port

#include <FirmwareVersion.h> // the "TMotorType" values below have changed a bit between versions of RobotC

#if kRobotCVersionNumeric >= 400
#define tmotorVex269 9989
#define tmotorVex393 9990
#define tmotorVex393HighSpeed 9991
#else
#define tmotorVex269_HBridge 9992
#define tmotorVex269_MC29 9993
#define tmotorVex393_HBridge 9994
#define tmotorVex393_MC29 9995
#define tmotorVex393HighSpeed_HBridge 9996
#define tmotorVex393HighSpeed_MC29 9997
#endif
#if kRobotCVersionNumeric < 426
#define tmotorVex393TurboSpeed_HBridge 9998
#define tmotorVex393TurboSpeed_MC29 9999
#endif

const ubyte kNumPowers = 255;

float rpm[kNumPowers]; // stores the calculated RPM for each PWM value
byte trueSpeedArray[kNumPowers]; // the array that will be generated

void generateTrueSpeed() {
    const ubyte kDeadZone = 0; // set a "deadzone" ± about 0 where trueSpeed will be set to 0
    const ubyte kNumMotors = 2; // number of motors to run during the generation
    const tMotor kEncoderPort = port1; // the encoder's port/name
    const tMotor kMotorPort[kNumMotors] = {kEncoderPort, port3}; // the motor(s)'s ports/names
    const TMotorTypes kMotorType = motorType[kEncoderPort]; // save encoder motor's type
    const short kSettleTime = 100; // milliseconds for motor(s)'s speed to settle
    const short kSampleTime = 300; // milliseconds for motor(s) to run for calculating RPM
    
    float ticksPerRev = 0.0; // number of ticks read by encoder per motor revolution
    float minRPM = 0.0; // minimum RPM seen
    float maxRPM = 0.0; // maximum RPM seen
    float rpmIncrement = 0.0; // desired RPM difference between consecutive trueSpeed array elements
    float arrayRPM = 0.0; // stores the desired RPM for each trueSpeed array element as the array is generated
    float rpmDiff = 2097200.0; // used to determine the PWM value that will yield an RPM closest to the desired RPM
    
    // clear all RPM values
    for(ubyte i=0; i<kNumPowers; i++)
        rpm[i] = 0.0;
    
    // ==== determine number of ticks per revolution ====
    if(kMotorType == tmotorVex269 || kMotorType == tmotorVex269_HBridge || kMotorType == tmotorVex269_MC29)
        ticksPerRev = 240.448; // 269
    else if(kMotorType == tmotorVex393 || kMotorType == tmotorVex393_HBridge || kMotorType == tmotorVex393_MC29)
        ticksPerRev = 627.2; // 393
    else if(kMotorType == tmotorVex393HighSpeed || kMotorType == tmotorVex393HighSpeed_HBridge || kMotorType == tmotorVex393HighSpeed_MC29)
        ticksPerRev = 392; // 393 high speed
    else if(kMotorType == tmotorVex393TurboSpeed_HBridge || kMotorType == tmotorVex393TurboSpeed_MC29)
        ticksPerRev = 261.333; // 393 turbo speed
    
    writeDebugStreamLine("Battery voltage before: %1.3fV\n", nAvgBatteryLevel/1000.0); // print battery voltage
    
    // ==== calculate RPM for every PWM value ====
    for(byte i=-1; i<=1; i+=2) // once for negative, repeat for positive
        for(byte j=i*127; i*j>0; j-=i) { // increment through PWM values from ±127 to 1
            // ramp power to ±127 gradually
            while(motor[kMotorPort[0]] != j) {
                for(ubyte k=0; k<kNumMotors; k++)
                    motor[kMotorPort[k]] += motor[kMotorPort[k]] < j ? 1 : -1; // increment power by ±1
                wait1Msec(1); // short delay to cause ramping
            }
            wait1Msec(kSettleTime); // wait for motor(s)'s speed to settle
            nMotorEncoder[kEncoderPort] = 0;
            ClearTimer(T1);
            wait1Msec(kSampleTime); // allow motor(s) to run at speed for a short time
            rpm[j+127] = (nMotorEncoder[kEncoderPort]/ticksPerRev)/((float)time1[T1]/60000.0); // calculate RPM from encoder change over time
        }
    
    // ==== generate trueSpeed array ====
    for(sbyte i=-1; i<=1; i+=2) { // once for negative, repeat for positive
        minRPM = i*2097200.0;
        for(short j=0; i*j<=127; j+=i) {
            if(rpm[j+127] && i*rpm[j+127] < i*minRPM)
                minRPM = rpm[j+127]; // find minimum RPM
            else if(i*rpm[j+127] > i*maxRPM)
                maxRPM = rpm[j+127]; // find maximum RPM
        }
        rpmIncrement = i*(maxRPM - minRPM)/(126.0 - (float)kDeadZone); // calculate difference between consecutive trueSpeed array elements
        
        arrayRPM = minRPM;
        for(short j=kDeadZone+i; i*j<=127; j+=i) {
            rpmDiff = 2097200.0;
            for(short k=i; i*k<=127; k+=i) {
                if(abs(rpm[k+127] - arrayRPM) < rpmDiff) {
                    rpmDiff = abs(rpm[k+127] - arrayRPM);
                    trueSpeedArray[j+127] = k;
                }
                wait1Msec(1);
            }
            arrayRPM += i*rpmIncrement;
        }
    }
    
    // ==== print formatted function to the debug stream ====
    writeDebugStreamLine("Copy/paste the following function into your program:/n");
    writeDebugStreamLine("// compensates for non-linearity of control value vs speed curve");
    writeDebugStreamLine("sbyte trueSpeed(long input) {");
    writeDebugStreamLine("  const byte speed = (byte)limit(input, 127)");
    writeDebugStream("  const byte kSpeedArray[255] = {");
    
    for(ubyte i=0; i<kNumPowers-1; i++) {
        if(i%10 == 0 || i == 0)
            writeDebugStream("\n    ");
        writeDebugStream("%4d,", trueSpeedArray[i]);
    }
    writeDebugStream("%4d", trueSpeedArray[kNumPowers-1]);
    writeDebugStreamLine("};\n  return kSpeedArray[speed + 127];\n}\n");
    writeDebugStreamLine("Battery voltage after: %1.3fV", nAvgBatteryLevel/1000.0);
}

task main() {
    generateTrueSpeed();
    
    while(true)
        wait1Msec(100);
}