//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
// FL Is Same
// Reverse FR
// Reverse BL
// BR Is Same

float kp=0.3;
float conversionfactor=627.2/(3.14*3.25*1.41)
bool finished=true;
int flgoal;
int frgoal;
int blgoal;
int brgoal;

void forward(float distance)
{
    while(!finished){}
    flgoal=distance*conversionfactor;
    frgoal=distance*conversionfactor;
    blgoal=distance*conversionfactor;
    brgoal=distance*conversionfactor;
}
void backward(float distance)
{
    while(!finished){}
    flgoal=-distance*conversionfactor;
    frgoal=-distance*conversionfactor;
    blgoal=-distance*conversionfactor;
    brgoal=-distance*conversionfactor;
}
void strafeleft(float distance)
{
    while(!finished){}
    flgoal=-distance*conversionfactor;
    frgoal=distance*conversionfactor;
    blgoal=distance*conversionfactor;
    brgoal=-distance*conversionfactor;
}
void straferight(float distance)
{
    while(!finished){}
    flgoal=distance*conversionfactor;
    frgoal=-distance*conversionfactor;
    blgoal=-distance*conversionfactor;
    brgoal=distance*conversionfactor;
}

task drivePID()
{
	while(1)
    {
        while((abs(flgoal-SensorValue(fl))>50)) //probably should do all 4 but i was lazy
		{
			finished=false;
            motor[fl]=kp*(flgoal-SensorValue(fl));
            motor[fr]=kp*(frgoal-SensorValue(fr));
            motor[bl]=kp*(blgoal-SensorValue(bl));
            motor[br]=kp*(brgoal-SensorValue(br));
        }
        if(abs(flgoal-SensorValue(fl))<=50)
        {
            finished=true;
            flgoal=0;
            frgoal=0;
            blgoal=0;
            brgoal=0;
            SensorValue(fl)=0;
            SensorValue(fr)=0;
            SensorValue(bl)=0;
            SensorValue(br)=0;
        }
    }
}

