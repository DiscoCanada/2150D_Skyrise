//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
// FL Is Same
// Reverse FR
// Reverse BL
// BR Is Same

float kP=0.3;
float kDriveWidth = 7.5;
float kConversionFactor=627.2/(3.14*3.25*1.41)
float kTurnConversionFactor = nMotorEncoder[br]/kTicksPerRev*kWheelSize*pow(PI,2)*kDriveWidth/360;
float kAngles;
bool finished=true;
int kFlGoal;
int kFrGoal;
int kBlGoal;
int kBrGoal;
int kAnglesFR;
int kAnglesFL;
int kAnglesBL;
int kAnglesBR;



void turn(float angle, float direction)// Direction 1 = (Right 0 - 180) Direction 2 = (Left 181 - 360)
{
    if(direction == 1) // Turn Right
    {
        while(!finished){}
        kAnglesFL = angle * kTurnConversionFactor;
        -kAnglesFR = angle * kTurnConversionFactor;
        -kAnglesBL = angle * kTurnConversionFactor;
        kAnglesBR = angle * kTurnConversionFactor;
    }
    if (direction == 2)
    {
        while(!finished){}
        -kAnglesFL = angle * kTurnConversionFactor;
        kAnglesFR = angle * kTurnConversionFactor;
        kAnglesBL = angle * kTurnConversionFactor;
        -kAnglesBR = angle * kTurnConversionFactor;
    }
}

void forward(float distance)
{
    while(!finished){}
    kFlGoal=distance*kConversionFactor;
    kFrGoal=distance*kConversionFactor;
    kBlGoal=distance*kConversionFactor;
    kBrGoal=distance*kConversionFactor;
}
void backward(float distance)
{
    while(!finished){}
    kFlGoal=-distance*kConversionFactor;
    kFrGoal=-distance*kConversionFactor;
    kBlGoal=-distance*kConversionFactor;
    kBrGoal=-distance*kConversionFactor;
}
void strafeleft(float distance)
{
    while(!finished){}
    kFlGoal=-distance*kConversionFactor;
    kFrGoal=distance*kConversionFactor;
    kBlGoal=distance*kConversionFactor;
    kBrGoal=-distance*kConversionFactor;
}
void straferight(float distance)
{
    while(!finished){}
    kFlGoal=distance*kConversionFactor;
    kFrGoal=-distance*kConversionFactor;
    kBlGoal=-distance*kConversionFactor;
    kBrGoal=distance*kConversionFactor;
}

task drivePID()
{
	while(1)
    {
        while((abs(kFlGoal-SensorValue(fl))>50) && abs(abs(kFrGoal-SensorValue(fr))>50) && (abs(kBlGoal-SensorValue(bl))>50) && (abs(kBrGoal-SensorValue(br))>50)) //probably should do all 4 but i was lazy
		{
			finished=false;
            motor[fl]=kP*(flgoal-SensorValue(fl));
            motor[fr]=kP*(frgoal-SensorValue(fr));
            motor[bl]=kP*(blgoal-SensorValue(bl));
            motor[br]=kP*(brgoal-SensorValue(br));
        }
        if(abs(kFlGoal-SensorValue(fl))<=50 && abs(kFrGoal-SensorValue(fr))<=50 && abs(kBlGoal-SensorValue(bl))<=50 && abs(kBrGoal-SensorValue(br))<=50)
        {
            finished=true;
            flgoal=0;
            frgoal=0;
            blgoal=0;
            brgoal=0;
            SensorValue(fl)=0;
            SensorValue(fr)=0;
            SensorValue(bl)=0;
            SensorValue(br)=0;
        }
    }
}

// So circumference formula is PI*d
task turnPID()
{
    while (1)
    {
        while ((abs(kAnglesFL - SensorValue(fl))>50) && (abs(kAnglesFR - SensorValue(fr)>50) && (abs(kAnglesBL - SensorValue(bl)>50) && (abs(kAnglesBR - SensorValue(br)>50))
        {
            finished=false;
            motor[fl]=kP*(kAnglesFL-SensorValue(fl));
            motor[fr]=kP*(kAnglesFR-SensorValue(fr));
            motor[bl]=kP*(kAnglesBL-SensorValue(bl));
            motor[br]=kP*(kAnglesBR-SensorValue(br));
        }
        if((abs(kAnglesFL - SensorValue(fl))<=50) && (abs(kAnglesFR - SensorValue(fr)<=50) && (abs(kAnglesBL - SensorValue(bl)<=50) && (abs(kAnglesBR - SensorValue(br)<=50))
        {
            finished=true;
            kAnglesFL = 0;
            kAnglesFR = 0;
            kAnglesBL = 0;
            kAnglesBR = 0;
            SensorValue(fl) = 0;
            SensorValue(fr) = 0;
            SensorValue(bl) = 0;
            SensorValue(br) = 0;
        }
    }
}

            
void driverControl()
{
    
}
//[11/6/14, 7:33:04 AM] Jordan Kiesel: So Harry then divide by 360 to get number of inches per degree.
//[11/6/14, 7:33:13 AM] Griffin Tabor: harry to calculate
//find distance from center of robot to center of a wheel
//PI*kDriveWidth/360.