#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    rtLiftPot,      sensorPotentiometer)
#pragma config(Sensor, in2,    lftLiftPot,     sensorPotentiometer)
#pragma config(Sensor, in3,    driveTurn,      sensorGyro)
#pragma config(Sensor, in4,    skyriseDetect,  sensorReflection)
#pragma config(Sensor, in5,    cubeColor,      sensorReflection)
#pragma config(Sensor, dgtl1,  dumpCubes,      sensorDigitalOut)
#pragma config(Sensor, dgtl2,  DtoV,           sensorDigitalOut)
#pragma config(Sensor, dgtl4,  proxSensor,     sensorSONAR_inch)
#pragma config(Sensor, dgtl6,  rtLiftZero,     sensorTouch)
#pragma config(Sensor, dgtl7,  lftLiftZero,    sensorTouch)
#pragma config(Sensor, dgtl10, light1,         sensorDigitalOut)
#pragma config(Sensor, dgtl11, light2,         sensorDigitalOut)
#pragma config(Sensor, dgtl12, light3,         sensorDigitalOut)
#pragma config(Sensor, I2C_1,  rtDrive1,       sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_2,  rtDrive2,       sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_3,  lftDrive1,      sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_4,  lftDrive2,      sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Motor,  port2,           rtDrive1,      tmotorVex393HighSpeed_MC29, openLoop, encoderPort, I2C_1)
#pragma config(Motor,  port3,           rtDrive2,      tmotorVex393HighSpeed_MC29, openLoop, encoderPort, I2C_2)
#pragma config(Motor,  port4,           rtLift1,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           rtLift2,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           lftLift2,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           lftLift1,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           lftDrive2,     tmotorVex393HighSpeed_MC29, openLoop, encoderPort, I2C_3)
#pragma config(Motor,  port9,           lftDrive1,     tmotorVex393HighSpeed_MC29, openLoop, encoderPort, I2C_4)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*-------------------------------------------------------------------------------*/
/* Harrison's(2150D's)Competition Code                                         	 */
/* Copyright (c) 2014 Harrison Freni-Chadwick Robotics                         	 */
/* Protected by the LGPL V. 3 Licences                                         	 */
/* Helpers: Emma Taulli, Devin Codon, Elias Wu(Team 254), Ruiqi Mao, and jPearman*/
/* Helpers(cont'd): Phil Nazarian, Madeliene Gradney, Frank Taulli							 */
/*-------------------------------------------------------------------------------*/

// Set Platform Information
#pragma platform(VEX)
//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

//Includes
#include "Vex_Competition_Includes.c" //Main competition background code...do not modify!
#include "Constants.h"
#include "liftControls.h"
#include "intakeControls.h"
#include "DriveControls.h"

//Auton Stuffs
#include "Menu.h"
#include "Auton.h"

void pre_auton()
{
	// Resets
	PIDreset();
	resetDrive();

	//Set Lights to Zero
	SensorValue[light1] = 1;
	SensorValue[light2] = 0;
	SensorValue[light3] = 0;

	//Turn on LCD Backlight
	clearLCDLine(0);
	clearLCDLine(1);
	bLCDBacklight = true;

	// Task Manager
	bStopTasksBetweenModes = true;
	//Allows for LCD Selector to Run
	startTask(Menu);
	//Makes Sure Lift is Zeroed
	startTask(liftZero);
	////Start PTC Lib
	//startTask(smart_PTC_monitor);
}

task autonomous()
{
	// Turn The LCD Backlight On
	bLCDBacklight = true;

	// Naming Convention, Due to Multiple Counts Running
	int finalCount = count;

	//Make Sure Lights are off
	SensorValue[light1] = 0;
	SensorValue[light2] = 1;
	SensorValue[light3] = 0;

	// Set The Intake to Open
	SensorValue[dumpCubes] = 0;

	//Stop The Menu Task
	stopTask(Menu);

	//Consult The Menu Class to Run Autonomous Mode
	switch (finalCount)
	{
	case 0:
		{
			autonomous0();
			break;
		}
	case 1:
		{
			autonomous1();
			break;
		}
	case 2:
		{
			autonomous2();
			break;
		}
	case 3:
		{
			autonomous3();
			break;
		}
	case 4:
		{
			autonomous4();
			break;
		}
	case 5:
		{
			autonomous5();
			break;
		}
	case 6:
		{
			autonomous6();
			break;
		}
	case 7:
		{
			autonomous7();
			break;
		}
	case 8:
		{
			autonomous8();
			break;
		}
	case 9:
		{
			autonomous9();
			break;
		}
	case 10:
		{
			autonomous10();
			break;
		}
	case 11:
		{
			autonomous11();
			break;
		}
	case 12:
		{
			autonomous12();
			break;
		}
	case 13:
		{
			autonomous13();
			break;
		}
	case 14:
		{
			autonomous14();
			break;
		}
	case 15:
		{
			autonomous15();
			break;
		}
	case 16:
		{
			testing();
			break;
		}
	case 17:
		{
			programming();
			break;
		}
	}
}

task usercontrol()
{
	//Start The Menu Up for Non-Comp Situations
	startTask(Menu);

	//Reset The Drive Encoders
	resetDrive();

	//Set LCD Backlight On
	bLCDBacklight = true;

	//Driver Control Loop
	while (true)
	{
		SensorValue[light1] = 0;
		SensorValue[light2] = 0;
		SensorValue[light3] = 1;

		intakeOpControlComp();
		driveOpControlComp();
		liftOpControlComp();
	}
}
